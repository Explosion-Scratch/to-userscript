<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>EventBus/Runtime Polyfill Test</title>
    <style>
        body {
            font-family: sans-serif;
        }

        #results {
            margin-top: 1em;
        }

        .pass {
            color: green
        }

        .fail {
            color: red
        }
    </style>
</head>

<body>
    <h1>EventBus & Runtime Polyfill Tests</h1>
    <div id="results"></div>
    <script src="runtimePolyfill.js"></script>
    <script>
        // ===================================================================
        // 3) Test Harness
        // ===================================================================
        const resultsEl = document.getElementById("results");
        let total = 0, passed = 0;
        function assert(desc, cond) {
            total++;
            const pass = !!cond;
            if (pass) passed++;
            const div = document.createElement("div");
            div.className = pass ? "pass" : "fail";
            div.textContent = (pass ? "✔ " : "✖ ") + desc;
            resultsEl.appendChild(div);
        }

        // Create two iframes
        const iframe1 = document.createElement("iframe");
        const iframe2 = document.createElement("iframe");
        iframe1.src = "about:blank";
        iframe2.src = "about:blank";
        document.body.appendChild(iframe1);
        document.body.appendChild(iframe2);

        // Wait until both iframes are loaded and ready
        new Promise(r => setTimeout(r, 100)).then(() => {
            // Inject same script into iframes via srcdoc
            const frameHTML = `
      <!DOCTYPE html><html><body>
      <script>
        ${createEventBus.toString()};
        
        ${createRuntime.toString()};
        // bootstrap
        const iframeBus = createEventBus("iframe");
        const runtime = createRuntime("tab", iframeBus);

        // Expose in window for parent tests
        window._bus = iframeBus;
        window._runtime = runtime;
      <\/script>
      </body></html>
    `;
            iframe1.srcdoc = frameHTML;
            iframe2.srcdoc = frameHTML;

            // Wait a tick for __INIT__ to flow
            setTimeout(setupTests, 50);
        });

        function setupTests() {
            // Page-context bus+runtime
            const pageBus = createEventBus("page", { children: [iframe1.contentWindow, iframe2.contentWindow] });
            const bg = createRuntime("background", pageBus);

            // Register background listeners under test:
            function syncEcho(msg) { return { echo: msg }; }
            function delayedEcho(msg, sendResponse) {
                if (msg.delay) {
                    setTimeout(() => sendResponse({ delayed: true }), 100);
                    return true;
                }
            }
            function promEcho(msg) {
                if (msg.prom) {
                    return new Promise(res => setTimeout(() => res({ prom: msg.prom }), 150));
                }
            }

            bg.onMessage.addListener(syncEcho);
            bg.onMessage.addListener(delayedEcho);
            bg.onMessage.addListener(promEcho);

            // Grab iframe runtimes
            const runtimes = [iframe1.contentWindow._runtime, iframe2.contentWindow._runtime];

            // Run tests in sequence
            let idx = 0;
            function nextTest() {
                if (idx >= runtimes.length) {
                    // test removing listener
                    bg.onMessage.removeListener(promEcho);
                    runtimes[0].sendMessage({ prom: "nope" }).then(res => {
                        assert("promEcho removed => no prom reply", !res.prom);
                        finish();
                    });
                    return;
                }
                const rt = runtimes[idx++];

                // 1) Promise style
                rt.sendMessage({ hello: 1 }).then(res => {
                    assert(`iframe${idx} promise-style basic echo`, res.echo.hello === 1);
                    return rt.sendMessage({ delay: true });
                }).then(res => {
                    assert(`iframe${idx} promise-style delayed`, res.delayed === true);
                    return rt.sendMessage({ prom: "y" });
                }).then(res => {
                    assert(`iframe${idx} promise-style prom`, res.prom === "y");
                    return Promise.resolve();
                })

                    // 2) Callback style
                    .then(() => new Promise(done => {
                        rt.sendMessage({ hello: 2 }, res => {
                            assert(`iframe${idx} callback basic echo`, res.echo.hello === 2);
                            done();
                        });
                    }))

                    // 3) With options object
                    .then(() => new Promise(done => {
                        rt.sendMessage({ hello: 3 }, res => {
                            assert(`iframe${idx} callback+options echo`, res.echo.hello === 3);
                            done();
                        }, { foo: "bar" });
                    }))

                    // 4) Add a per-iframe onMessage then remove it
                    .then(() => {
                        function oneOff(msg, sendResponse) {
                            if (msg.foo === "bar") sendResponse({ ok: true });
                        }
                        bg.onMessage.addListener(oneOff);
                        return rt.sendMessage({ foo: "bar" }).then(res => {
                            assert(`iframe${idx} dynamic listener fired`, res.ok === true);
                            bg.onMessage.removeListener(oneOff);
                            return rt.sendMessage({ foo: "bar" });
                        });
                    })

                    .then(res => {
                        assert(`iframe${idx} dynamic listener removed`, !res.ok);
                    })

                    .then(nextTest)
                    .catch(e => console.error(e));
            }

            nextTest();
        }

        function finish() {
            const summary = document.createElement("h3");
            summary.textContent = `Passed ${passed} / ${total} tests`;
            resultsEl.appendChild(summary);
        }
    </script>
</body>

</html>